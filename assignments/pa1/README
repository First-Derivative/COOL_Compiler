README file for Programming Assignment 1: Frontend
==================================================

For this assignment, you need the following files:

 assignments/pa1/README
 assignments/pa1/test.cl
 assignments/pa1/bad.cl
 assignments/pa1/good.cl
 assignments/pa1/mycoolc
 src/CoolLexer.g4
 src/CoolParser.g4
 src/ASTBuilder.java
 src/StringTable.java
 src/Utilities.java
 src/TreeConstants.java
 src/CoolErrorListener.java
 src/CoolErrorStrategy.java
 src/Flags.java
 src/Frontend.java
 src/ast/*.java
 src/ast/visitor/*.java
 bin/buildme
 testsuite/lexer
 testsuite/parser


 README this file. It contains detailed instructions for the
   assignment as well as a number of useful tips.  You can update
   the README to explain your design decisions, explain why your
   code is correct.  This will be taken into account during code
   review.  It is part of the assignment to clearly and concisely
   explain things in text as well as to comment your code.  Just
   edit this file.

 CoolLexer.g4 CoolParser.g4 is a template file for the
   specification of the lexical and syntactic analyzer.  This
   template will compile and run as is, but it doesn't do much.
   You should read the Antlr4 manual to figure out what this
   template does do and how to extend it.

   In the lexer template, we have given you names and lexer rules
   for some of the terminals.  In the parser template, we have
   provided some parts of some rules. You should not need to
   modify this code to get a working solution, but you are
   welcome to if you like.  However, do not assume that any
   particular rule is complete.  Use them as an example to write
   the remaining rules. You might also need to add precedence
   declarations.

 ASTBuilder.java You can use this file for code that creates the
   abstract syntax tree at the end of parsing. There are several
   ways to implement it. One way to do it is to traverse the
   parse tree using CoolParserBaseVisitor, automatically
   generated by ANTLR, and create the corresponding AST. Whatever
   approach you choose, place all your changes in this file, and
   do not edit any files in the ast package.

 ast/*.java
   The ast package provides classes for abstract syntax trees. 
   See assignment handout for details.
   DO NOT MODIFY.

 ast/visitor/*.java The ast.visitor package provides classes
   for traversing abstract syntax trees, using Visitor Design
   Pattern. DumpVisitor pretty-prints the AST in the format
   compatible with subsequent phases.
   DO NOT MODIFY.

 test.cl is a Cool program that you can test the lexical
   analyzer on. It contains some errors, so it won't compile with
   coolc. Note that test.cl does not exercise all lexical
   constructs of Cool. Nevertheless, it is an interesting test.
   It is not a good test to start with, nor does it provide
   adequate testing of your lexer.

 good.cl, bad.cl test a few features of the grammar. You can
   add tests to ensure that good.cl exercises every legal
   construction of the grammar and that bad.cl exercises as many
   different parsing errors as you can squeeze into one file.  If
   there is any intentional and known difference between reference
   lexer/parser and your implementation, there should be tests here
   that demonstrate it. Explain your tests in these
   files and put any overall comments in the \U{README} file.
   This will be taken into account during code review.

   Part of your assignment is to come up with good testing inputs
   and a testing strategy.  (Don't take this lightly---good test
   input is difficult to create, and forgetting to test something
   is the most likely cause of lost points during grading.)

 mycoolc is a shell script that glues together the components of the
   compiler using Unix pipes instead of statically linking code.  
   While inefficient, this architecture makes it easy to mix and match
   the components you write with those of the course compiler.

 StringTable.java  contain string table data structures.
   DO NOT MODIFY.

 TreeConstants.java defines some useful symbol constants.
   You may add some of your own, if you wish. 

 CoolErrorListener.java CoolErrorStrategy.java declare error
   error reporting and handling. 

 Utilities.java contains various support functions used by the
   main Frontend driver.
   DO NOT MODIFY.

 Flags.java implements routines for parsing command line flags.
   DO NOT MODIFY.

 Frontend.java implements the main Frontend driver, i.e., reads
   the input file and command line arguments and calls the
   lexer and the parser.
   DO NOT MODIFY.

 bin/buildme contains sample commands for compiling and running your
   program.

   The build directory will contain the scanner and parser generated by
   Antlr4 from Cool*.g4.  DO NOT MODIFY IT, as your changes will
   be overwritten the next time you run Antlr4. Instead, edit Cool*.g4
   and these files will be regenerated automatically.	

Instructions
------------

  To compile your frontend, type 

    buildme frontend 

  This runs Antlr4, compiles all the classes and produces a frontend.

  To run your frontend, put your test input in a file 'foo.cl' and type

    ./myfrontend foo.cl
        
  myfrontend is a shell script which invokes Frontend.main() as
  the standalone component of the Cool compiler.   It requires 
  analysis and backend to compile a Cool program.

  To run your lexer without parser:

    ./myfrontend -x foo.cl

  If you think your frontend is correct and behaves like
  the one we wrote, you may want to run a COOL compiler using
  your frontend.

    ./mycoolc foo.cl

  and see whether it runs and produces correct code for any
  examples.  If your lexical and syntactic analyzer behaves in
  an unexpected manner, you may get errors anywhere, i.e. during
  parsing, during semantic analysis, during code generation or
  only when you run the produced code on spim. So beware.

  To run the testsuites:

    testme lexer parser
